
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Sand Flow Field</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        background: white;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  </head>
  <body>
    <script>
      let particles = [];
      let flowField = [];
      let cols, rows;
      let inc = 0.1;
      let scl = 10;
      let zoff = 0;

      function setup() {
        createCanvas(window.innerWidth, window.innerHeight);
        cols = floor(width / scl);
        rows = floor(height / scl);
        flowField = new Array(cols * rows);

        for (let i = 0; i < 1000; i++) {
          particles[i] = new Particle();
        }

        background(255);
      }

      function draw() {
        let yoff = 0;
        for (let y = 0; y < rows; y++) {
          let xoff = 0;
          for (let x = 0; x < cols; x++) {
            let index = x + y * cols;
            let angle = noise(xoff, yoff, zoff) * TWO_PI * 4;
            let v = p5.Vector.fromAngle(angle);
            v.setMag(1);
            flowField[index] = v;
            xoff += inc;
          }
          yoff += inc;
        }
        zoff += 0.001;

        for (let i = 0; i < particles.length; i++) {
          particles[i].follow(flowField);
          particles[i].update();
          particles[i].edges();
          particles[i].show();
        }
      }

      class Particle {
        constructor() {
          this.pos = createVector(random(width), random(height));
          this.vel = createVector(0, 0);
          this.acc = createVector(0, 0);
          this.maxspeed = 2;
          this.prevPos = this.pos.copy();
        }

        update() {
          this.vel.add(this.acc);
          this.vel.limit(this.maxspeed);
          this.pos.add(this.vel);
          this.acc.mult(0);
        }

        applyForce(force) {
          this.acc.add(force);
        }

        show() {
          stroke(0, 10); // black stroke on white background
          strokeWeight(1);
          line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y);
          this.prevPos = this.pos.copy();
        }

        edges() {
          if (this.pos.x > width) {
            this.pos.x = 0;
            this.prevPos.x = 0;
          }
          if (this.pos.x < 0) {
            this.pos.x = width;
            this.prevPos.x = width;
          }
          if (this.pos.y > height) {
            this.pos.y = 0;
            this.prevPos.y = 0;
          }
          if (this.pos.y < 0) {
            this.pos.y = height;
            this.prevPos.y = height;
          }
        }

        follow(vectors) {
          let x = floor(this.pos.x / scl);
          let y = floor(this.pos.y / scl);
          let index = x + y * cols;
          let force = vectors[index];
          this.applyForce(force);
        }
      }

      function windowResized() {
        resizeCanvas(window.innerWidth, window.innerHeight);
        background(255);
      }
    </script>
  </body>
</html>
